// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}
                                                                              
float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    //return float3(1, 0, 0);
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

float3 SampleDirection(int sample, uint id) {
    //return float3(0, 1, 0);
    float z = 1 - 2*Random(float(2*id + 3*sample));
    float phi = Random(float(2*id + 3*sample +1))*2*PI;
                 
    return float3(sqrt(1.0f - z*z) * cos(phi), sqrt(1.0f - z*z) * sin(phi), z);
}

float f(int id, float3 direction) {  
   float coeff1 = sqrt(3)/(2*sqrt(PI));
   float coeff2 = sqrt(15)/(2*sqrt(PI));
   float res[9] = {-coeff1 * direction.y, 
                   coeff1 * direction.z, 
                   -coeff1 * direction.x,  
                   1/(2*sqrt(PI)), 
                   coeff2*direction.y*direction.x, 
                   -coeff2*direction.y*direction.z, 
                   -coeff2*direction.x*direction.z, 
                   sqrt(5)*(3*direction.z*direction.z - 1)/(4*sqrt(PI)), 
                   sqrt(15)*(direction.x*direction.x - direction.y*direction.y)/(4*sqrt(PI))};

   return res[id];   
}

float4 SampleRes0(float3 direction) {
   float coeff = sqrt(3)/(2*sqrt(PI)); 
   coeff *= coeff;
   return float4(coeff * direction.x, coeff * direction.y, coeff * direction.z,   1/(4*PI));
}

float4 SampleRes1(float3 direction) {
   float coeff = sqrt(15)/(2*sqrt(PI)); 
   coeff *= coeff;
   return float4(coeff*direction.y*direction.x, coeff*direction.y*direction.z, coeff*direction.x*direction.z, 
                 5*(3*direction.z*direction.z - 1)/(16*PI));
}

float SampleRes2(float3 direction) {
    return 15*(direction.x*direction.x - direction.y*direction.y)/(16*PI);
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 24;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };
    

    for (int sample = 0; sample < SAMPLES; ++sample) {
        float3 direction = SampleDirection(sample, id);
        float3 color = SampleColor(direction); 
        float4 res0 = SampleRes0(direction);
        float4 res1 = SampleRes1(direction);
        float res2 = SampleRes2(direction);
        results[0] += res0 * color.r;
        results[1] += res0 * color.g;
        results[2] += res0 * color.b;
        results[3] += res1 * color.r;
        results[4] += res1 * color.g;
        results[5] += res1 * color.b;
        results[6] += float4(res2 * color.r, res2 * color.g, res2 * color.b, 0);
    } 

    for (int i = 0; i < 7; ++i) {
        results[i] /= SAMPLES;
        results[i] *= PI;
    }
    
    // TASK: project light from _Env to spherical harmonic coefficients;
    // Multiply that by the same polynom coeffients, because they appear in the projection of max(0, cos(theta)) 
    // and store them in results[]
    
    for (int c = 0; c < 3; c++)
    {
        // Precomputing coefficients of max(0, cos(theta) for L=0
        results[c].w *= PI; 
        // Precomputing coefficients of max(0, cos(theta) for L=1
        results[c].xyz *= PI * 2 / 3;
    }
    
    for (c = 0; c < 4; c++)
    {
        // Precomputing coefficients of max(0, cos(theta) for L=2
        results[3 + c] *= PI / 4;
    }      
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];

    SH_2_rgb[id] = results[6];    
}
